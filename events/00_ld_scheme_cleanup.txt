namespace = ld

character_event = {
    id = ld.2000
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        # ROOT = dead character

        # Mark related characters for bounded cleanup
        every_close_family_member = {
            set_character_flag = ld_queue_cleanup_needed
        }

        # MP Safe: end player schemes targeting ROOT
        if = {
            limit = { ld_is_mp_safe_mode = yes }
            every_player = {
                every_scheme = {
                    limit = {
                        is_active = yes
                        scheme_target_character = { same_character = ROOT }
                    }
                    end_scheme = yes
                }
            }
        }
    }
}
# ===============================
# War ended scheme cleanup
# ===============================
game_event = {
    id = ld.2100
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            # Mark war participants (bounded set)
            if = {
                limit = { exists = scope:war }
                scope:war = {
                    every_war_participant = {
                        set_character_flag = ld_recent_war_participant
                    }
                }

                # End player schemes targeting invalid war participants
                every_player = {
                    every_scheme = {
                        limit = {
                            is_active = yes
                            scheme_target_character = {
                                has_character_flag = ld_recent_war_participant
                                OR = {
                                    is_alive = no
                                    exists = no
                                }
                            }
                        }
                        end_scheme = yes
                    }
                }

                # Cleanup temp flags
                scope:war = {
                    every_war_participant = {
                        clr_character_flag = ld_recent_war_participant
                    }
                }
            }
        }
    }
}
# ===============================
# Title transfer cleanup (covers "title loss" via previous_holder)
# ===============================
character_event = {
    id = ld.2201
    hide_window = yes
    is_triggered_only = yes

    immediate = {

        # Mark new holder (root) for bounded cleanup
        if = { limit = { exists = ROOT } ROOT = { set_character_flag = ld_queue_cleanup_needed } }

        # Mark previous holder too (they "lost" the title)
        if = { limit = { exists = scope:previous_holder } scope:previous_holder = { set_character_flag = ld_queue_cleanup_needed } }

        # MP Safe: only end schemes that are *objectively invalid*
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            every_player = {
                every_scheme = {
                    limit = {
                        is_active = yes
                        scheme_target_character = {
                            OR = {
                                is_alive = no
                                exists = no
                            }
                        }
                    }
                    end_scheme = yes
                }
            }
        }
    }
}
# ===============================
# Title destroyed cleanup
# on_title_destroyed provides scope:landed_title
# ===============================
character_event = {
    id = ld.2200
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            if = {
                limit = { exists = scope:landed_title }
                scope:landed_title = {
                    if = {
                        limit = { exists = holder }
                        holder = { set_character_flag = ld_queue_cleanup_needed }
                    }
                }
            }
        }
    }
}

# ===============================
# Prison cleanup (root = prisoner, scope:imprisoner = captor)
# ===============================
character_event = {
    id = ld.2300
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        # Only act in MP Safe mode
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            # End player-owned schemes targeting the newly imprisoned character (ROOT)
            every_player = {
                every_scheme = {
                    limit = {
                        is_active = yes
                        scheme_target_character = { same_character = ROOT }
                    }
                    end_scheme = yes
                }
            }

            # Optional: mark involved characters for bounded manager cleanup
            ROOT = { set_character_flag = ld_queue_cleanup_needed }
            scope:imprisoner = { set_character_flag = ld_queue_cleanup_needed }
        }
    }
}

# ===============================
# Prison release cleanup (root = released prisoner, scope:imprisoner = former imprisoner)
# ===============================
character_event = {
    id = ld.2301
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            # Optional: mark for bounded cleanup
            ROOT = { set_character_flag = ld_queue_cleanup_needed }
            scope:imprisoner = { set_character_flag = ld_queue_cleanup_needed }
        }
    }
}
# ===============================
# Travel cancelled cleanup
# ===============================
character_event = {
    id = ld.2400
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            # Root is usually the traveller; if your on_action uses a different scope,
            # we’ll adjust once we confirm vanilla scopes.
            ROOT = { set_character_flag = ld_queue_cleanup_needed }

            # Conservative: only end schemes if target is dead/missing
            every_player = {
                every_scheme = {
                    limit = {
                        is_active = yes
                        scheme_target_character = {
                            same_character = ROOT
                            OR = { is_alive = no exists = no }
                        }
                    }
                    end_scheme = yes
                }
            }
        }
    }
}

# ===============================
# Travel arrived cleanup
# ===============================
character_event = {
    id = ld.2401
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            ROOT = { set_character_flag = ld_queue_cleanup_needed }

            # Conservative: only end schemes if target is dead/missing
            every_player = {
                every_scheme = {
                    limit = {
                        is_active = yes
                        scheme_target_character = {
                            same_character = ROOT
                            OR = { is_alive = no exists = no }
                        }
                    }
                    end_scheme = yes
                }
            }
        }
    }
}
# Activity completed
character_event = {
    id = ld.2500
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            # Root/scope depends on vanilla; once you paste the vanilla block, I’ll lock these scopes.
            if = { limit = { exists = ROOT } ROOT = { set_character_flag = ld_queue_cleanup_needed } }

            # Conservative scheme cleanup: only if target is objectively invalid
            every_player = {
                every_scheme = {
                    limit = {
                        is_active = yes
                        scheme_target_character = { OR = { is_alive = no exists = no } }
                    }
                    end_scheme = yes
                }
            }
        }
    }
}

# Activity cancelled
character_event = {
    id = ld.2501
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            if = { limit = { exists = ROOT } ROOT = { set_character_flag = ld_queue_cleanup_needed } }

            every_player = {
                every_scheme = {
                    limit = {
                        is_active = yes
                        scheme_target_character = { OR = { is_alive = no exists = no } }
                    }
                    end_scheme = yes
                }
            }
        }
    }
}
# Marriage created
character_event = {
    id = ld.2600
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            # Root scope depends on vanilla: we’ll lock it once you paste the vanilla blocks
            ROOT = { set_character_flag = ld_queue_cleanup_needed }

            if = { limit = { exists = scope:spouse } scope:spouse = { set_character_flag = ld_queue_cleanup_needed } }

            # Conservative: end schemes only if target is dead/missing
            every_player = {
                every_scheme = {
                    limit = {
                        is_active = yes
                        scheme_target_character = { OR = { is_alive = no exists = no } }
                    }
                    end_scheme = yes
                }
            }
        }
    }
}
# ===============================
# Guardian assigned cleanup
# ===============================
character_event = {
    id = ld.2700
    hide_window = yes
    is_triggered_only = yes

    immediate = {
        if = {
            limit = { ld_is_mp_safe_mode = yes }

            ROOT = { set_character_flag = ld_queue_cleanup_needed }
            if = { limit = { exists = scope:guardian } scope:guardian = { set_character_flag = ld_queue_cleanup_needed } }

            # Conservative scheme cleanup
            every_player = {
                every_scheme = {
                    limit = {
                        is_active = yes
                        scheme_target_character = { OR = { is_alive = no exists = no } }
                    }
                    end_scheme = yes
                }
            }
        }
    }
}
